# -*- coding: utf-8 -*-
"""Trabalho_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x44ocGbYYYh8Utf3D5d8pxxka7Vz6tW_
"""

import numpy as np
import random as rd
from random import randint

class Mochila():

  def __init__(self, nomeArquivo):
    self.itens = []
    self.pesos = []
    self.valores = []

    arquivo = open(nomeArquivo, 'r')

    self.pesoLimite = float(arquivo.readline());
    for linha in arquivo:
      linhaSeparada = linha.split(' ')
      self.itens.append(int(linhaSeparada[0]))
      self.valores.append(float(linhaSeparada[1]))
      self.pesos.append(float(linhaSeparada[2]))
    
  def imprimirMochila(self):
    print('Peso Limite  {}\n'.format(self.pesoLimite))
    print('Itens Disponíveis:')
    for i in range(len(self.itens)):
      print('\nItem  {}'.format(self.itens[i]))
      print('Valor {}'.format(self.valores[i]))
      print('Peso  {}'.format(self.pesos[i]))
    print('--------\n')

  def imprimirMochilaSelecionada(self, itensSelecionados, pesoTotal):
    print('Peso Limite  {}\n'.format(self.pesoLimite))
    print('Peso Total  {}\n'.format(pesoTotal))
    print('Itens Selecionados:')
    for i in range(len(itensSelecionados)):
      if itensSelecionados[i] == 1:
        print('\nItem  {}'.format(self.itens[i]))
        print('Valor {}'.format(self.valores[i]))
        print('Peso  {}'.format(self.pesos[i]))
    print('--------\n')

class InicializaAlgoritmoGenetico():
  #para que todos os AG's utilizem dos mesmos dados iniciais:
  def __init__(self, mochila):
    self.mochila = mochila

    self.solucoesPorPopulacao = 20
    self.tamanhoPopulacao = (self.solucoesPorPopulacao, len(self.mochila.itens))

    #inicializa a população randomicamente com 0 ou 1
    self.populacao = np.random.randint(2, size = self.tamanhoPopulacao)
    self.populacao = self.populacao.astype(int)

    self.numeroGeracoes = self.populacao.shape[1] * 2
    self.numeroPais = int(self.tamanhoPopulacao[0]/2)
    self.numeroDesc = self.tamanhoPopulacao[0] - self.numeroPais

class AlgoritmoGenetico():

  def __init__(self, AGInicial, tipoSelecao, tipoCrossover, tipoSelecaoSobreviventes):
    self.mochila = AGInicial.mochila

    self.tipoSelecao = tipoSelecao
    self.tipoCrossover = tipoCrossover
    self.tipoSelecaoSobreviventes = tipoSelecaoSobreviventes

    self.solucoesPorPopulacao = AGInicial.solucoesPorPopulacao
    self.tamanhoPopulacao = AGInicial.tamanhoPopulacao

    self.populacao = AGInicial.populacao.copy()

    self.numeroGeracoes = AGInicial.numeroGeracoes
    self.numeroPais = AGInicial.numeroPais
    self.numeroDesc = AGInicial.numeroDesc

  def imprimirPopulacao(self, inicialFinal):
    print('População ' + inicialFinal + ': \n{}\n'.format(self.populacao))

  def imprimirAptidao(self, inicialFinal):
    print('Aptidão da Geração ' + inicialFinal + ': \n{}\n'.format(self.aptidao))

  def imprimirMelhorAptidao(self, inicialFinal):
    aptidaoMaxima = np.where(self.aptidao == np.max(self.aptidao))
    print('Melhor Aptidão da Geração ' + inicialFinal + ': \n{}\n'.format(self.aptidao[aptidaoMaxima[0][0]]))

  def imprimirPesos(self, inicialFinal):
    print('Pesos da Geração ' + inicialFinal + ': \n{}\n'.format(self.pesoTotal))

  def calculaAptidao(self, populacao):
    self.pesoTotal = np.empty(populacao.shape[0])
    aptidao = np.empty(populacao.shape[0])
    #para cada item da população
    for i in range(populacao.shape[0]):
      #pega a soma dos produtos da população e valor
      somaProdutoPopValor = np.sum(populacao[i] * self.mochila.valores)
      #pega a soma dos produtos da população e peso
      somaProdutoPopPeso = np.sum(populacao[i] * self.mochila.pesos)

      #se o peso for menor ou igual ao limite o fitness guarda esse valor
      if somaProdutoPopPeso <= self.mochila.pesoLimite:
          aptidao[i] = somaProdutoPopValor
      #se a aptidao for inválida, guarda o valor do peso
      else:
          aptidao[i] = -somaProdutoPopPeso
      
      self.pesoTotal[i] = somaProdutoPopPeso

    self.pesoTotal = self.pesoTotal.astype(float)
    aptidao = aptidao.astype(float) 
    return self.transfomarAptidaoNegativa(aptidao)

  def transfomarAptidaoNegativa(self, aptidao):  
    #essa função transforma as aptidões inválidas em válidas com um valor mínimo, 
    #para que o algoritmo seja capaz de selecionar sempre o elemento menos pior da população
    aptidaoOrdenada = sorted(aptidao, reverse=True)
    aptidaoRank = sorted(range(len(aptidao)),key=aptidao.__getitem__, reverse=True)
    for i in range(len(aptidaoOrdenada)):
      if aptidaoOrdenada[i] < 0.0:
        aptidao[aptidaoRank[i]] = (len(aptidaoOrdenada) - i) / 1000
    return aptidao

  def selecao(self):
    aptidaoTotal = np.sum(self.aptidao) 

    if aptidaoTotal == 0:
      self.selecaoAleatoria()
      return

    if self.tipoSelecao == 'Roleta Viciada':
      self.selecaoRoletaViciada()
    elif self.tipoSelecao == 'Torneio':
      self.selecaoTorneio()
    else:
      self.selecaoAleatoria()

  def selecaoRoletaViciada(self):
    self.aptidao = list(self.aptidao)

    self.pais = np.empty((self.numeroPais, self.populacao.shape[1]))

    countPais = 0
    aptidaoTotal = np.sum(self.aptidao) 
      
    while countPais < self.numeroPais:
      for i in range(self.numeroPais):
        pick = rd.uniform(0, aptidaoTotal)
        current = 0
        for j in range(self.populacao.shape[0]):
          current += self.aptidao[j]
          if current > pick:
            self.pais[i] = self.populacao[j]
            countPais = countPais + 1
            break;

  def selecaoTorneio(self):
    self.aptidao = list(self.aptidao)

    self.pais = np.empty((self.numeroPais, self.populacao.shape[1]))

    k = 2

    for i in range(self.numeroPais):
      aptidaoAux = rd.sample(self.aptidao, k)
      #seleciona o maior fitness dos pais em k
      aptidaoMaxima = np.where(aptidaoAux == np.max(aptidaoAux)) 
      #seleciona o pai com o maior fitness da lista em k
      self.pais[i,:] = self.populacao[aptidaoMaxima[0][0], :]

  def selecaoAleatoria(self):
    self.pais = np.empty((self.numeroPais, self.populacao.shape[1]))
    idx = np.random.randint(self.populacao.shape[0], size=self.pais.shape[0])
    self.pais = self.populacao[idx,:]

  def crossover(self):
    if self.tipoCrossover == 'Um Ponto de Corte':
      self.crossoverUmPonto()
    elif self.tipoCrossover == 'Dois Pontos de Corte':
      self.crossoverDoisPontos()
    else:
      self.crossoverUniforme()

  def crossoverUmPonto(self):
    self.descendentes = np.empty((self.numeroDesc, self.pais.shape[1]))
    i = 0
    while i < self.numeroPais:
      ponto = rd.randint(1, self.pais.shape[1] - 1) 
      pai1Index = i%self.pais.shape[0]
      pai2Index = (i+1)%self.pais.shape[0]

      self.descendentes[i,0:ponto] = self.pais[pai1Index,0:ponto]
      self.descendentes[i,ponto:] = self.pais[pai2Index,ponto:]

      self.descendentes[i+1,0:ponto] = self.pais[pai2Index,0:ponto]
      self.descendentes[i+1,ponto:] = self.pais[pai1Index,ponto:]

      i= i+2

  def crossoverDoisPontos(self):
    self.descendentes = np.empty((self.numeroDesc, self.pais.shape[1]))
    i = 0
    while i < self.numeroPais:
      ponto1 = rd.randint(1, self.pais.shape[1] - 3) 
      ponto2 = rd.randint(ponto1 + 1, self.pais.shape[1] - 1) 

      pai1Index = i%self.pais.shape[0]
      pai2Index = (i+1)%self.pais.shape[0]

      pai1Corte1 = self.pais[pai1Index,0:ponto1]
      pai1Meio = self.pais[pai1Index,ponto1:ponto2]
      pai1Corte2 = self.pais[pai1Index,ponto2:]

      pai2Corte1 = self.pais[pai2Index,0:ponto1]
      pai2Meio = self.pais[pai2Index,ponto1:ponto2]
      pai2Corte2 = self.pais[pai2Index,ponto2:]

      self.descendentes[i,0:ponto1] = pai1Corte1
      self.descendentes[i,ponto1:ponto2] = pai2Meio
      self.descendentes[i,ponto2:] = pai1Corte2

      self.descendentes[i+1,0:ponto1] = pai2Corte1
      self.descendentes[i+1,ponto1:ponto2] = pai1Meio
      self.descendentes[i+1,ponto2:] = pai2Corte2

      i= i+2

  def crossoverUniforme(self):
    self.descendentes = np.empty((self.numeroDesc, self.pais.shape[1]))

    i = 0
    while i < self.numeroPais:
      mascara = np.random.randint(2, size=(self.pais.shape[1]))

      pai1Index = i%self.pais.shape[0]
      pai2Index = (i+1)%self.pais.shape[0]

      j = 0
      for m in mascara:
        if m == 1:
          self.descendentes[i,j] = self.pais[pai1Index,j]
          self.descendentes[i+1,j] = self.pais[pai2Index,j]
        else:
           self.descendentes[i,j] = self.pais[pai2Index,j]
           self.descendentes[i+1,j] = self.pais[pai1Index,j]
        j = j+1
      i= i+2

  def mutacao(self):
    self.mutacoes = np.empty((self.descendentes.shape))

    #taxa de mutação
    taxaMutacao = 0.4

    for i in range(self.mutacoes.shape[0]):
      random_value = rd.random()
      self.mutacoes[i,:] = self.descendentes[i,:]
      if random_value > taxaMutacao:
        continue
      int_random_value = randint(0,self.descendentes.shape[1]-1)    
      if self.mutacoes[i,int_random_value] == 0 :
        self.mutacoes[i,int_random_value] = 1
      else :
        self.mutacoes[i,int_random_value] = 0

  def selecaoSobreviventes(self):
    aptidao = self.calculaAptidao(self.populacaoTotal)
    aptidaoTotal = np.sum(aptidao) 

    if aptidaoTotal == 0:
      self.selecaoSobreviventesAleatoria()
      return

    if self.tipoSelecaoSobreviventes == 'Elitismo':
      self.selecaoSobreviventesElitismo()
    elif self.tipoSelecaoSobreviventes == 'Ranking':
      self.selecaoSobreviventesRanking()
    else:
      self.selecaoSobreviventesAleatoria()

  def selecaoSobreviventesElitismo(self):
    aptidao = self.calculaAptidao(self.populacaoTotal)
    aptidao = list(aptidao)
    for i in range(self.populacao.shape[0]):
      #seleciona o maior fitness da lista
      aptidaoMaxima = np.where(aptidao == np.max(aptidao)) 
      #seleciona o elemento com o maior fitness da lista
      self.populacao[i,:] = self.populacaoTotal[aptidaoMaxima[0][0], :]
      #seta o maior fitness para um valor mínimo, para que o mesmo não seja selecionado novamente
      aptidao[aptidaoMaxima[0][0]] = -999999

  def selecaoSobreviventesRanking(self):
    #i    -> individuo
    #t    -> geração
    #min  -> pior fit
    #max  -> melhor fit
    #n    -> numero de individuos da população
    #E(i,t) = min + (max - min) * ((rank(i,t) - 1)/(n-1))

    aptidaoRank = self.calculaAptidao(self.populacaoTotal)
    aptidaoRank = sorted(range(len(aptidaoRank)),key=aptidaoRank.__getitem__, reverse=True)
    min = aptidaoRank[aptidaoRank[-1]]
    max = aptidaoRank[aptidaoRank[0]]
    n = self.populacaoTotal.shape[0]

    E = np.empty(self.populacaoTotal.shape[0])
    for i in range(self.populacaoTotal.shape[0]):
      rank = aptidaoRank.index(i) + 1; #maior rank = 1
      E[i] = min + (max - min) * ((rank - 1)/(n-1))

    E = list(E)
    for i in range(self.populacao.shape[0]):
      #seleciona o maior E da lista
      eMaxima = np.where(E == np.max(E)) 
      #seleciona o elemento com o maior E da lista
      self.populacao[i,:] = self.populacaoTotal[eMaxima[0][0], :]
      #seta o maior E para um valor mínimo, para que o mesmo não seja selecionado novamente
      E[eMaxima[0][0]] = -999999


  def selecaoSobreviventesAleatoria(self):
    idx = np.random.randint(self.populacaoTotal.shape[0], size=self.populacao.shape[0])
    self.populacao = self.populacaoTotal[idx,:]

  def imprimirMochilaSelecionada(self):
    for i in range(self.populacao.shape[0]):
      self.mochila.imprimirMochilaSelecionada(self.populacao[i], self.pesoTotal[i])
    

  def run(self):
    #self.mochila.imprimirMochila()
    #self.imprimirPopulacao('Inicial')
    ultimasAptidoes = list()
    j = 0
    for i in range(self.numeroGeracoes):
      self.aptidao = self.calculaAptidao(self.populacao)

      if j < 4:
        ultimasAptidoes.append(self.aptidao.copy())
        j = j + 1
      elif np.sum(ultimasAptidoes[0]) > 2 and np.array_equal(ultimasAptidoes[0], ultimasAptidoes[3]):
        print('Qntd Gerações: {}'.format(i))
        break
      else:
        ultimasAptidoes = list()
        j = 0

      self.selecao()
      self.crossover()
      self.mutacao()
      self.populacaoTotal = np.concatenate((self.populacao.astype(int), self.mutacoes.astype(int)))
      self.selecaoSobreviventes()
        
    #self.imprimirPopulacao('Final') 
    self.aptidao = self.calculaAptidao(self.populacao)      
    self.imprimirAptidao('Final')
    #self.imprimirMelhorAptidao('Final')
    #print("Peso Limite: {}".format(self.mochila.pesoLimite))
    #self.imprimirPesos('Final')
    #self.imprimirMochilaSelecionada()

tipoSelecao = ['Roleta Viciada', 'Torneio', 'Aleatória']

tipoCrossover = ['Um Ponto de Corte', 'Dois Pontos de Corte', 'Uniforme']

tipoSelecaoSobreviventes = ['Elitismo', 'Ranking', 'Aleatória']

mochila = Mochila('ks_i8000.txt')
algoritmoGeneticoInicial = InicializaAlgoritmoGenetico(mochila)

agRoleta = AlgoritmoGenetico(algoritmoGeneticoInicial, tipoSelecao[0], tipoCrossover[0], tipoSelecaoSobreviventes[0])
agRoleta.run()

agTorneio = AlgoritmoGenetico(algoritmoGeneticoInicial, tipoSelecao[1], tipoCrossover[0], tipoSelecaoSobreviventes[0])
agTorneio.run()

agAleatoria = AlgoritmoGenetico(algoritmoGeneticoInicial, tipoSelecao[2], tipoCrossover[0], tipoSelecaoSobreviventes[0])
agAleatoria.run()